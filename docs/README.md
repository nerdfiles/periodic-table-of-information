# Periodic Table of Information

PTI is largely concerned with providing a specification for HTML to dictate
how it is to be treated in a fully peer-2-peer network of cryptographic miners
which might also support cryptographic messaging for OTR purposes. We combine
the concepts of PGP with public domain actions to formalize behaviors
irrespective to their visibility or anonymity. Actions as microdata make sense
from an architectural standpoint whether on the Open Web or Dark Web, but we
seek to describe how PGP standards can be allotted "rooms" through
disitributed ledger technologies. How can we achieve ephemeral message passing
such that a conversation provably did not happen? This is the goal of PTI.

I want to make `OP_RETURN` transactions to the Bitcoin blockchain and open
rooms in an [HTTP-layering](layering) in a WebSocket such that the web page
itself has a public key and the OP_RETURN contains a hash of the public keys
licensed to see the room. (For instance, [dualapi][dp] proves that the
question of [WebSockets versus REST][wsvrest] can be reconciled. Another
interesting point when it comes to REST requirements concerns Code on Demand
which we find viable through RequireJS, also enabling [client-side hot
re-loading][hot]. Generally we believe in

1. _Configuration Over Convention_.
2. _Uniformity Over Isomorphy_.<br />
   Politically speaking, _Propertization Over Privatization_; i.e., _Differences Cannot Be Taxed Or Agreements Would Never Be_.
3. _Hypermedia As the Engine of Application State_.

The overall philosophy of PTI might be called _narratological functionalism_;
or: _the discourse is the message_. Critically, we *must not* allow the
draconian telecommunications providers to dictate the level-of-support for
the web, which is "fundamentally a distributed hypermedia application" ([Taylor,
Medividovic, Dashofy][dist]. 2010.).

## Kingdom of Parsers

Searching trees is what is imagined the Discovery layer of PTI specifies, in
accordance with worst-case practical Byzantine fault tolerance; pruning and
searching trees of HTTP Statuses: (201 + 304 + 500) is a path that has a
deterministic resolution but 500 has a fixed timeout, 201 might not have a
fixed timeout because an entity is created, 304 might not have a fixed timeout,
etc. [HTTP Statuses][statuses] become the child nodes in a tree of relational
translations of modal formulas for Discovery* concerning time resolutions of
REST-ful state transitions which subtend the distributed hypermedia application.
There are _authentication paths_ and _discovery paths_ in the digital ecology
of the distributed ledgers which account for the distributed hypermedia
application.

And all of this has a cost to humans which can be accounted for in a
blockchain so to determine how much service time is needed to support an OTR
conversation between certain public identities along an authentication path.

I'm imagining "web applications" are things like:

    https://GIS_ID.grocery.store/ID/isle/2

and I can have an OTR conversation with every item in the isle that provably
does not occur. Ultimately things like "kroger.com" become increasingly
meaningless. Hierarchies and ownership become increasingly meaningless as each
item in the isle can have a public key such that the `/isle/` is a room.
Hypermedia as the engine of application state would specify then that
`/isle/next` means I move from one room to the next such that a series of HTTP
statuses deterministically resolution to a merkle root which can be specified
in HTML pages given a target difficulty on the antichain.

## Theoretical Shores

Periodic Table of Information is a consequence of adoption of a dual-aspect
neutral monism that is defended in Baruch Spinoza's Ethics Ordine Geometrico.
To say that information has a periodic nature in itself sounds counterintuitive,
and indeed certain ontological ramifications are pertinent to disclose; chief of
those being the view that the Higgs Boson and the concept of Gravitational Waves
are seen as fundamentally untenable theoretical posits. Waves cannot transmit
gravity, and the Higgs boson is more of a useful fiction than it is a consistent
model within the theory which makes its supposition.

The Periodic Table of Information concerns itself with the relationship between
the indiscernible and the undecidable, by way of evidence of the
indistinguishability of photons. One thing to understand is that the Periodic
Table of Information's constructivisitic nature requires a full rejection the
concept of the Higgs boson because of its presupposition that time is not an
independent dimension that is ever measured. The intellectual goal of PTI
should be achieved, essentially, if a coherent response to John McTaggart's
argument for the Unreality of Time is grounded in the Spinozistic
expression of the mental categories implicated in a mathematical formalism of
the quantum theory insofar as time, specifically the A Series, is philosophically
constituted as the 4th dimension of space, rather than an independent dimension
that comports a chimerical notion of the "arrow of time." A corollary of the
formalism (formal input specification language) given here is that certain
notions of time travel, global simulations, forms of zombie consciousness, and
other philosophical "thought experiments" are strictly hubris, if not completely
(philosophical or epistemological) category mistakes, akin to AJ Ayer's
proposition, and defense, that there had been a sun before there were any humans
to see it.

We follow our theoretical basis to an innocuous conclusion: that people do not
create wealth; rather, people create economic momentum. Time's theoretical
placement within the formalism requires such an epistemic departure in order to
make consistent the descriptive model of "state spaces" of 4D space. Otherwise,
we would invariably confuse the C Series with the A Series through the use of
isomorphisms which underpin calculate of unit norm vectors within the unitary
evolution of projection in Banach space.

<img
  src="https://raw.githubusercontent.com/nerdfiles/periodic-table-of-information/master/docs/images/banach-space-projection.png"
  alt="Subprojective Banach state spaces for 3 closed-timelike curves expressed in Cartesian modality"
  title="Subprojective Banach state spaces for 3 closed-timelike curves expressed in Cartesian modality"
  width="200"
/>

What we are concerned with in such demonstrations is the theoretical contours
of the von Neumann supposition that "mind causes collapse." More importantly,
that the yield of worlds, or Many-worlds, is an entailment of decoherence, as
opposed to evidence merely that the measurement apparatus is out of scope of
the mathematical observer. We are indeed concerned with the "temporal dead
zone"[0] that supplies new information; hence the name, "Periodic Table of
Information." PTI is an expression of the declarative reference architecture
necessary to describe formalized mathematical observers within a 4D Minkowski
(state) space.

## Hypermedia Factors

We adopt Mike Amundsen's [Hypermedia Factors][hfactor] for Hypermedia Types in
order to achieve a description of Hypermedia Scale cyberspaces. Saving for
a more fitting area for exposition, our notion of "cyberspace" begins with the
assumption that _space is timeless_. More aptly, the features of cyberspaces
which supervene on the web as a distributed hypermedia application are
timelessness, versionlessness, serverlessness, permissionlessness,
tokenlessness, keylessness, trustlessness, domainlessness, passwordlessness,
and modelessness. A fully-distributed system, then, must provably secure these
properties as a coherent technological gestalt. Heidegger be damned! Long live
Descriptivism!

One benefit of bringing the web of such a nature to fruition is that the
Anarchic Ideal should be achieved:

<blockquote>
<p>The future organization of society must proceed from the bottom up only,
through free association or federation of the workers, into their
associations to begin with, then into communes, regions, nations and,
nally, into a great international and universal federation.</p>
<cite>Mikhail Bakunin</cite>
</blockquote>

Moreover, we are to achieve that _ideal of a society_ such that

<blockquote>
<p>It would not answer its purpose if it did not cover society with a network
of thousands of associations to satisfy its thousand needs: the
necessaries of life, articles of luxury, of study, enjoyment, amusements.</p>
<cite>Mutual Aid. Petyr Kropotkin</cite>
</blockquote>

Thank goodness folks smarter than us have laid the groundwork for these natural
extensions to the social ecology.

### Notes on the "Web of Trust"

As expression of support for the [Web of Trust](http://xmlns.com/wot/0.1/). A
bit of clarification might be in order. Users of PGP/GPG keys are typically
described as "agents, persons, groups, or organizations." We might think these
terms strictly grammatical or technical in nature, but assessing them with an
epistemological eye we might recast them as "people, businesses, content, and
devices." It's a matter of cryptographic narratological discourse.

For our purposes we are absorbing the standards of the Web of Trust directly
into our assessment of Hypermedia Factors. For instance, when we talk of a
`<foaf:Person>` with `<PubKey>` we are also potentially talking about a
[Person][P] of a public domain ontology. Our use of the term "Web of Trust" is
not accidental or unintentional. Our effort is exactly to bridge WoT
relations and events with Actions as they transpire on the web; more
importantly, such actions bear direct consequences on the internal activities
of peer-2-peer networks which might be supported by distributed cryptographic
ledger technologies and blockchain technologies in terms of linking to public
key signature events or linking to endorsement resources. The narration
layer may very well link to a public key which corresponds to an identity
(`Ai`) which might be scattered throughout web documents that are
transactional in nature (are the result of transmedia factors).

### Context Layer

#### Relations        [Cl]

#### Read             [Cr]

#### Update           [Cu]

#### Method           [Cm]

### Narration Layer

#### Embed            [Le]

#### Outbound         [Lo]

#### Templated        [Lt]

#### Nonidempotent    [Ln]

#### Idempotent       [Li]

## Discovery Layer*

### Overview

Consider the following modal proof:

    ◊∃x□(∃y(y = x) ∧ Rx) ⊢ ∃x□(∃y(y=x) ∧ Rx)

Don't worry; we have worked it out by hand as well, but here is a proof tree
for to mull over:

<img
  src="https://raw.githubusercontent.com/nerdfiles/periodic-table-of-information/master/docs/images/modal-proof.png"
  alt="Caption as Translation Below"
  width="300"
  style="width: 300px; float: right;"
/>

Now we might be wondering how this relates to REST. Generally, we are often
concerned with a logarithmic number of queries. This might be the case in
most cases because we can translate the proof as follows:

    Possibly, there exists a[n HTTP Response] that is maximally represented in
    every possible HTTP Request.

With its conclusion being:

    There exists a[n HTTP Response] that is maximally represented in every
    possible HTTP Request.

This is a non-trivial result that enables us to talk about classifying
bounded resolutions to HTTP Status combinatics in polynomial time. Critically,
identifying the dependencies of queries within a framework of modal formulas
enables the application of capabilities to oracles within our stream of
validations. Particularly, distributed ledgers can become not merely
validators of transactions, but they can ensure the stability of the network
through distributed parallelism.

An outcome of this strategy is that we can define _hypernodes_ of the network
in such a way that HTTP Statuses play a role in our determination of the
commissioning and decommissioning of a virtual logical layer of the distributed
ledger environment. The Periodic Table of Information then becomes a rubric
for identifying what we have at an earlier time called "degradable media
models" such that the Web of Trust and the Chain of Trust become expressions
of the substrate logical layer of the distributed hypermedia application (web).
That said, fault tolerance becomes a question of the parity of maximalized
attributes described given certain resolution of the formal input specification
language and its actual realizability within the _hypertree_ of distributed smart
contracts which are positively solved, insofar as they are _almost surely valid_,
in polynomial time. However, our chief concern is bridging the unitary evolution
of periodic categorical changes in economic momentum of the distributed ledger
environment insofar as it is an ecosystem of existing and newly created public
key relationships, each of which contributes to the expansion and contraction of
dynamical wealth velocities over time.

### Diagnose          [Di]

#### Modal Schema

    □PK0 → □□PK0      (transitive [metastructure] key distribution)

#### Order of Platitude

    If Node stores p, then the truth of Node’s motive for p must have been
    ensured through the exercise of Node’s relevant technological abilities.

#### Measurement Category

    O(log n)

#### Measurement Scenario

Given a person’s name, find the account number by picking a random point about
halfway through the part of the ledger you haven’t searched yet, then checking
to see whether the person’s name is at that point. Then repeat the process
about halfway through the part of the ledger where the person’s name lies.
This is a binary search for a person’s name.

### Recovery          [Re]

#### Modal Schema

    □PK0 → PK0        (reflexive key distribution)

#### Order of Platitude

    Only purposeful information is stored.

#### Measurement Category

    O(nˆn)

#### Measurement Scenario

You fix the bot so that it’s loading things correctly. The next day, one of
your co-devs plays a prank on you and codes the file watcher bot to the
automated insert script. Every time the bot goes to load an original ledger,
the factory DBMS makes a duplicate run of all the ledgers! Fortunately, the
bot’s bug-detection systems are sophisticated enough that the bot doesn’t try
inserting even more copies when it encounters a duplicate ledger for loading,
but it still has to load every original and duplicate ledger that’s been
printed.

### Rollback          [Ro]

#### Modal Schema

    ◊□PK0 → □◊PK0     (convergent key distrituion)

#### Order of Platitude

    False information is not stored.

#### Measurment Category

    O(1) (worst case)

#### Measurement Scenario

Given the page that an organization’s name is on and the organization name,
find the account number.

### Retry             [Rt]

#### Modal Schema

    ◊PK0 → □◊PK0      (Euclidean key distribution)

#### Order of Platitude

    Information excludes stochastic luck.

#### Measurement Category

    O(n)

#### Measurement Scenario

Find all people whose account numbers contain the digit “5”.

### Mask              [Ma]

#### Modal Schema

    PK0 → □◊PK0       (symmetric key distribution)

#### Order of Platitude

    If Node asserts p, then all machines can confirm that Node knows p.

#### Measurement Category

    O(1) (average case)

#### Measurement Scenario

Given the page that a person’s name is on and their name, find the account
number.

### Confinement       [Co]

#### Modal Schema

    □□PK0 → □PK0      (dense key distribution)

#### Order of Platitude

    Node stores all deductions of p assuming Node stores ancestry of p.

#### Measurement Category

    O(n log n)

#### Measurement Scenario

We want to annotate the ledger, so we’re going to find each person or
organization’s name in their designated copy, then circle their name in the
ledger and append a small note regarding a recent customer service call.

### Serial            [Se]

#### Modal Schema

    □PK0 → ◊PK0       (serial key distribution)

#### Order of Platitude

    Information is a technological achievement.

#### Measurement Category

    O(n)

#### Measurement Scenario

Given a account number, find the person or organization with that number.

## Transmedia Factors

As expression of support for the Chain of Trust. Generally we are outlining a
capability of fully peer-2-peer systems to express people identity rules and
transaction identity requirements in one place, the lingua franca of the web: the
hypertext markup language. One crude way to think of this is that
Create-Read-Update-Delete (CRUD) is achieveable through information dispersal norms
accounting for sharded states of data to be "proved." Practically this is the
thinking that the `action` of a form can point to public APIs like
http://blockchain.info or https://blockr.io/tx/push.

### NoBackend P2P Form Processing

Create `OP_RETURN` using Bitcore's `Script.fromHumanReadable` updating the
`TransactionBuilder` to `_setFeeAndRemainder` with `OP_RETURN {{someData}}`
for your determined transaction. Then post the raw transaction. For example:

    $http({
      method  : 'POST',
      url     : 'https://blockchain.info/pushtx?cors=true',
      data    : { 'tx': transactionHex },
      headers : {
        "Content-Type": "application/x-www-form-urlencoded"
      }
    }).then((response) => {
      console.log(response);
    }, (error) => {
      console.log(error);
    });

Instead of a mail server sending a mail, a small script scans for the Bitcoin
address specified for receipt of payment. We are looking at the cost of hosting
a microtransaction from an endpoint versus pay-as-you-go to a wallet that is
independent of the hosting service, itself capable of servicing the web form.
The application will actually check any keyservers for the public key ID to
determine the `From:` field, say on a contact form. One could therefore create
a throw-away public key for submitting forms, meanwhile the `To:` field is
technically a Bitcoin address connected with a Bitcoin address configured to
the web form. The Web application can scan the Bitcoin blockchain's public
transaction ledger whenever, optimally at the verification period, do a lookup
of the PGP key. The data of the form will be formatted, calculated and sharded
according to the limitations of the `OP_RETURN` such that multiple transactions
will be made. Essentially the OP_RETURN will be a pairing

    OP_RETURN <public_key_id_or_email> <public_key_id_or_email> <startTime>
    OP_RETURN LWZ_Compressed_PGP_MESSAGE('-----BEGIN PGP MESSAGE-----\
    \
    hQIMA6rjpgDbFMWQARAAtjtXC28NFCuswfmY5VJIwex6cO8ms+AldPxpKQX2Wd4i\
    ...\
    =6y2I\
    -----END PGP MESSAGE-----')
    OP_RETURN <public_key_id_or_email> <public_key_id_or_email> <endTime>

If the lookup works, the form data will be signed, sharded, and sent as however
many transactions are necessary per chunks of the message as max input size. The
messages should be coded to LocalStorage and queued for transaction. So, instead
of coding a backend to receive e-mails one has the more complicated affair of
implementing Bitcore to build a transaction with `OP_RETURN`! But more
interestingly, practically a backend isn't needed at all. If the transaction(s)
are made from the web form, they will be encrypted, compressed, etc.

Now, of course this would be horribly expensive on the Bitcoin blockchain as it
stands today. And maybe even some of the description is terribly non-lucid.
More likely it makes sense to use a closed-loop ledger and pass unitary
evolution of state periodically to the Bitcoin blockchain such that a momentum
system is devised to account for the temporal aspect of business transactions
which dynamically track income level capacities between public identities.

### Value Layer

Translate [Mt]

    <meta
        name="translate"
        content="PROTOCOL_VERSION"
    />

Peers [Mp]

    <meta
        name="peers"
        content="1SandCPeDm95MEXLzCkIKaWFBmK5vYNR81,1ZingAkI72kmooZLzCkYLtYUYm8KvYNRER"
    />

#### Copy             [Mc]

Copy specifies whether or not the given document is dependent on a full copy of
the blockchain or a partial copy. That is to say, should the document follow the
narrative protocol of SPV nodes who filter for it, or is it dependent on a full
copy of the blockchain database? The document itself determines which kinds of
nodes are relevant to its life cycle along the lines of the pool servers that are
available to make that life cycle possible.

Copy should be specified in the `<head>` of an HTML document though the `<meta>` tag:

    <meta
        name="copy"
        content="full"
    />

Or for Solo Miners:

    <meta
        name="copy"
        content="solo"
    />

Or for SPVs:

    <meta
        name="copy"
        content="spv"
    />

Or for Reference Clients:

    <meta
        name="copy"
        content="reference"
    />

#### Block            [Mb]

Block can be somewhat misleading. It actually refers to `merkelblock` which identifies
the block header and the merkel path that links a transaction of interest to the merkle
root in the block.

    <meta
        name="block"
        content="d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3"
    />

#### Diminution       [Md]

Diminution is concerned with explicitly identifying the Target Difficulty of
the given document insofar as its threshold considerations in the PoW.

    <meta
        name="diminution"
        content="0000000000000003A30C00000000000000000000000000000000000000000000"
    />

#### More Details

##### Nodes

###### Mining Nodes

###### Wallet Nodes

###### Full Nodes

###### Routing Nodes

### Attribution Layer

Currently the following are merely examples of the relevant atomic elements
which might pertain to the given meta-elements. So we might consider:

    <meta
        name="identity:fingerprint"
        content="{{value}}"
    />

At the present time it is not entirely clear how `Type` and `Verb` might be
delineated according to this specification; however, what is imagined is that
any entity or asset which can be described in a cryptographic ledger for
trading purposes, etc., should possess its own web page (likely an HTML
representation). Accessing "raw images" for instance should never happen, and
even considering entities like `/helicopter` should be context-free in its
principle description, even if it might never be accessed outside of a domain,
its description language should principally support domain-less attribution.

#### Identity         [Ai]

PGP identities make sense for humans, machines, corporations, and software code.

    <meta
        name="fingerprint"
        content="public_key"
    />

##### Relationship Certificates

We break from the common assumption that accounting is concerned only with the
creation of wealth. The given identity system is concerned with income
capacity, not strictly wealth differentials. One might consider this a new
departure from classical economic schools of thought in much the same way that
the quantum theory is a departure from Newtonian Physics. Given this departure
the classical assumption of the Rational Actor demands revision if such
concepts are to be integrated into an economics of cyberspace.

RCs apply to one of four types of agents: humans, machines, corporations, and
software agents. Ultimately, however, a human must be the root accountability
agent of all actions. Humans can create rules which may derive further rules
which compel machines, corporations, or software agents to act. A software
agent in common parlance will be nominalized as a "smart contract." It is
important however that the derivation of rules therefrom a human's decision is
codified by the creation of a relevant relationship certificate that represents
said derivation. It is not enough to identify a subclause of a smart contract
as such, but said clause must essentially depend for its processing on its
certificate's creation. So, a smart contract's compute depends not only on
its internal logic, but its internal logic's processing depends on a certificate
which might implicate the internal logic of another contract only through its
relevant relationship certificate. With such an explicit constraint for cybernetic
system are we able to realize [common consensus protocols][ccp] as the
assessment of platitudes of distributed consensus.

The system is "cybernetic" insofar as its integration of homomorphic
signatures. Purposefully, the system assumes the capability to compute over
encrypted datasets to homomorphically derive signatures of relevant
certificates, such that the identity of those subclauses of given contracts
while semantically conditioned do not give away the true identity of that
human whose root actions produced their derivation.

#### Type             [At]

See [InteractionCounter](https://schema.org/InteractionCounter).

#### Verb             [Aa]

See [Action](https://schema.org/Action). (If it helps, think of the verb
`to page` as in `to page someone`; now `to web page`. This should help with
thinking about the ontology pertaining to https://schema.org/WebPage). Now
then we might think of Web Pagers as the most basic metaphor for the
capabilities of a web page, insofar as a web pages most basic use-case. That
said, pages are the most accessible and usable devices ever created from a
cognitive to ergonomic standpoint.

#### Method           [Am]

    <meta
        name="method:csrf-token"
        content="{{some_csrf_token}}"
    />

A viable token format is JWT, though storing tokens client-side (LocalStorage, anybody?) depends on the implementation. The main point that we are establishing here is that the implementation depends on a certain "philosophical consideration."

So one thing I have been thinking is, say you have these HTTP Statuses: 205 Reset Content and 412 Precondition Failed. What is 412? Here's a relevant part:

    A server MUST ignore all received preconditions if its response to the
    same request without those conditions would have been a status code
    other than a 2xx (Successful) or 412 (Precondition Failed).  In other
    words, redirects and failures take precedence over the evaluation of
    preconditions in conditional requests.
    — https://tools.ietf.org/html/rfc7232#section-4.2

What this means is that all 412s have a known state which can be stored. Therefore: Node stores all deductions of p assuming Node stores ancestry of p (see above) and Node stores all deductions of p assuming Node stores ancestry of p (see above). So to say, we can identify optimal Discovery* paths which cohere with Authentication paths (a true idea coheres with its object — Axiom 6). In this case 30x and 50x take precedence in that a 412 is not stored if these were to be determined. From the perspective of automation of Discovery we can know this precognitively in that the cryptographic key pairings implicated along the Discovery* path can be known because sometimes we may use one-time keys (convergent keys) that are correlated with PGP keys. The HTML page might dictate that my public key annotating the HTML page entity is leveraged to produce a convergent key, but if the resources 30x or 50x that are child resources as [Link Relations][relations] then I might determine beforehand that such convergent keys cannot or MUST NOT be generated, etc. And this would all be transcribed in the closed-loop ledger's [account paths][paths].

So the keys become "lively" (in the scope of JWT implementation details which is partly informed by the Availability Confidence Model for the information type — so one corollary here is that information is a natural kind like "water" or "heat") based on these deterministic modal state space transitions of auth paths and discovery* for REST-ful resources like `/account/ID/thing` which is nothing more than a modal proof of the thing.

We are applying Kripke's causal theory of reference to REST. That's the raison d'étre here, turning REST-ful reasources into natural kinds; or so to say "every identity statement involving proper names is either necessarily true or necessarily false." Some REST-ful endpoints are proper names (Are all REST-ful endpoints proper names? `/cat` versus `/search?` We must also remember that REST does not _just mean_ prettier URLs — these URLs can still have CGI parameters like `?null=blah&super=block`) — like with the "grocery store" example above. Therefore, the necessary a posteriori MUST apply to cyberspace!

__

* Depends on Availability Confidence Model; a grammatical outcome of this concept is that information is _available at a possible world at such-and-such a time, t_.

[0]: A useful metaphor we have inherited from review of the JavaScript
programming language.

[layering]:   https://en.wikipedia.org/wiki/Representational_state_transfer#Layered_system
[P]:          https://schema.org/Person
[ccp]:        https://gist.githubusercontent.com/nerdfiles/20f58d0b9f12952de85cff10ef96599d/raw/b9e4c4277f2df1d56468d23ca5c0fb0b009241bf/common-consensus-protocols.md
[dp]:         https://www.npmjs.com/package/dualapi
[wsvrest]:    https://www.infoq.com/news/2012/02/websockets-rest
[hot]:        https://medium.com/@the1mills/hot-reloading-with-react-requirejs-7b2aa6cb06e1#.y6mnt2cjp
[dist]:       http://www.softwarearchitecturebook.com/about-the-book/
[hfactor]:    http://amundsen.com/hypermedia/
[statuses]:   https://httpstatuses.com/
[relations]:  https://www.iana.org/assignments/link-relations/link-relations.xhtml
[paths]:      https://docs.openchain.org/en/latest/api/ledger.html#account-paths
